<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Classifier Squares D3 Visualization (Scaled & LOD)</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #multi-class-container { width: 100%; min-height: 900px; overflow: auto; border:1px solid #ccc; padding:30px; background:#fafafa; }
    #multi-class-vis svg { display:block; overflow:visible; background:#fff; border-radius:8px; box-shadow:0 4px 8px rgba(0,0,0,0.08); }
    .legend { background:#f8f9fa; border:1px solid #ddd; border-radius:8px; padding:15px; margin-top:20px; font-size:12px; }
    .legend-item { display:inline-block; margin-right:20px; margin-bottom:8px; }
    .legend-color { display:inline-block; width:16px; height:16px; margin-right:5px; vertical-align:middle; border:1px solid #333; }
    .control-panel { margin-top: 20px; padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .axis text { font-size:12px; fill:#333; }
    .btn { padding:5px 10px; border:none; border-radius:4px; color:#fff; cursor:pointer; }
    .btn-green { background:#2ecc71; }
    .btn-red { background:#e74c3c; }
    .btn-blue { background:#3498db; }
  </style>
</head>
<body>
  <div>
    <label>üëÅÔ∏è View Mode:</label>
    <select id="view_mode">
      <option value="auto" selected>Auto (LOD)</option>
      <option value="boxes">Boxes</option>
      <option value="stacks">Stacks</option>
    </select>
  </div>
  <br>

  <div id="tooltip" style="position:absolute; display:none; background:white; border:1px solid #ccc; padding:6px 8px; pointer-events:none; font-size:12px; z-index:1000; box-shadow:0 2px 4px rgba(0,0,0,0.2); border-radius:4px;"></div>

  <div id="multi-class-container">
    <div id="multi-class-vis"></div>

    <div id="controls" class="control-panel">
      <div style="display:flex; gap:20px; align-items:center; flex-wrap:wrap;">
        <div>
          <label style="font-weight:bold;">üîó Parallel Coordinates:</label>
          <button id="toggle-polylines" class="btn btn-green" style="margin-left:6px;">Show</button>
          <small style="margin-left:6px; color:#666;">Hover instances to see cross-class scores</small>
        </div>
        <div>
          <label style="font-weight:bold;">‚≠ê Bookmarks:</label>
          <span id="bookmark-count" style="margin-left:6px; color:#666;">0 instances</span>
          <button id="clear-bookmarks" class="btn btn-red" style="margin-left:10px;">Clear</button>
        </div>
        <div>
          <label style="font-weight:bold;">üîç Filter:</label>
          <select id="instance-filter" style="margin-left:6px; padding:5px;">
            <option value="all">All Instances</option>
            <option value="bookmarked">Bookmarked Only</option>
            <option value="tp">True Positives (Correct)</option>
            <option value="fp">False Positives (Wrong Pred)</option>
            <option value="fn">False Negatives (Missed)</option>
            <option value="high-Prediction Score">High Prediction Score (>0.8)</option>
            <option value="low-Prediction Score">Low Prediction Score (<0.5)</option>
          </select>
        </div>
        <div>
          <label style="font-weight:bold;">üìä Analysis:</label>
          <button id="confusion-analysis" class="btn btn-blue" style="margin-left:6px;">Confusion Report</button>
        </div>
      </div>
    </div>

    <div class="legend">
      <h4 style="margin:0 0 10px 0; color:#333;">üìñ Visualization Legend</h4>
      <div style="display:flex; flex-wrap:wrap; gap:15px;">
        <div class="legend-item"><span class="legend-color" style="background:#3498db; border:none;"></span><strong>TP</strong>: colored box</div>
        <div class="legend-item"><span class="legend-color" style="background:#e74c3c; border:1px solid #333;"></span><strong>FP</strong>: colored fill + black border</div>
        <div class="legend-item"><span class="legend-color" style="background:white; border:1px solid #3498db;"></span><strong>FN</strong>: white + colored border</div>
        <div class="legend-item"><span style="display:inline-block; width:16px; height:2px; background:#333; margin-right:5px; vertical-align:middle;"></span><strong>Baseline</strong></div>
        <div class="legend-item"><span style="display:inline-block; width:16px; height:2px; background:#ff6b35; margin-right:5px; vertical-align:middle;"></span><strong>Polyline</strong></div>
      </div>
    </div>
  </div>

  <!-- Â§ñÈÉ®Êï∞ÊçÆÊ≥®ÂÖ•ÂÆπÂô®ÔºàÂèØÈÄâÔºâÔºöÂ¶ÇÊûúÁî® Python Ê≥®ÂÖ•ÔºåÂ°´ÂÖÖËøô‰∏§‰∏™ËÑöÊú¨Ê†áÁ≠æ -->
  <script id="instances-json" type="application/json"></script>
  <script id="classnames-json" type="application/json"></script>

  <script>
  function createClassifierSquaresVisualization(instances, classNames = null, opts = {}) {
    // ---------- Config ----------
    const cfg = {
      svgHeight: opts.svgHeight ?? 800,
      subplotWidth: opts.subplotWidth ?? 160,
      classOffset: 60,
      yAxisOffset: 45,
      marginTop: 50,
      marginBottom: 120,
      baselineX: 25,
      spacing: 2,
      minCell: 6,
      rowsPerBin: opts.rowsPerBin ?? 30,
      maxBoxesPerBinRender: 5000,
    };
    const colors = d3.schemeCategory10;
    const colorByClass = d3.scaleOrdinal(colors);

    // ---------- State ----------
    let bookmarked = new Set();
    let polylinesVisible = false;
    let currentFilter = "all";
    let iid = 0;

    // Êï∞ÊçÆÊ∏ÖÊ¥ó
    const data = instances.map(d => ({
      true_label: +d.true_label,
      pred_label: +d.pred_label,
      pred_score: +d.pred_score,
      class_scores: Array.isArray(d.class_scores) ? d.class_scores.map(Number) : null,
      match: d.true_label === d.pred_label ? "TP" : "FP", // ‚ÄúFN‚ÄùÂú®ÊØè‰∏™Á±ªÈù¢ÊùøÂÜÖ‰ΩìÁé∞
      class_focus: +d.true_label,
      instance_id: iid++
    }));

    const classes = Array.from(new Set(data.flatMap(d => [d.true_label, d.pred_label]))).sort((a,b)=>a-b);

    function updateBookmarkCount(){
      document.getElementById("bookmark-count").textContent = `${bookmarked.size} instances`;
    }

    // ËøáÊª§ÔºöÊåâ‚ÄúÂΩìÂâçÁ±ªÈáåÁöÑÁ±ªÂûã‚ÄùÔºàTP/FP/FNÔºâÂà§Êñ≠
    function shouldShow(d, typeForThisClass) {
      switch (currentFilter) {
        case "bookmarked": return bookmarked.has(d.instance_id);
        case "tp":         return typeForThisClass === "TP";
        case "fp":         return typeForThisClass === "FP";
        case "fn":         return typeForThisClass === "FN";
        case "high-Prediction Score": return d.pred_score >= 0.8;
        case "low-Prediction Score":  return d.pred_score < 0.5;
        default: return true;
      }
    }
    function binIndex(s){ return Math.min(Math.floor(s*10), 9); }

    // ---------- SVG ----------
    const svgWidth = Math.max(cfg.subplotWidth * classes.length + cfg.classOffset + cfg.yAxisOffset + 20, 1200);
    const root = d3.select("#multi-class-vis").html("");
    const svg = root.append("svg").attr("width", svgWidth).attr("height", cfg.svgHeight).attr("viewBox", `0 0 ${svgWidth} ${cfg.svgHeight}`);
    const main = svg.append("g").attr("class", "main");
    const poly = svg.append("g").attr("class", "polyline");

    const yTop = cfg.marginTop, yBottom = cfg.svgHeight - cfg.marginBottom;
    const yScale = d3.scaleLinear().domain([0,1]).range([yBottom, yTop]);
    const yBin = d3.scaleBand().domain(d3.range(10)).range([yBottom, yTop]).paddingInner(0.15);

    main.append("g").attr("class","axis").attr("transform", `translate(${cfg.yAxisOffset},0)`).call(d3.axisLeft(yScale).ticks(10));
    main.append("text").text("Prediction Score")
      .attr("x", cfg.yAxisOffset - 25).attr("y", cfg.svgHeight/2)
      .attr("text-anchor","middle").attr("transform", `rotate(-90, ${cfg.yAxisOffset - 25}, ${cfg.svgHeight/2})`)
      .style("font-size","12px").style("font-weight","bold").style("fill","#333");

    const classG = main.selectAll("g.cls")
      .data(classes, d=>d)
      .join("g")
      .attr("class","cls")
      .attr("transform", (cls, i) => `translate(${i*cfg.subplotWidth + cfg.classOffset + cfg.yAxisOffset},0)`);

    classG.selectAll("text.title")
      .data(d=>[d]).join("text")
      .attr("class","title")
      .text(d => (classNames && classNames[d]) ? `C${d} ¬∑ ${classNames[d]}` : `Class ${d}`)
      .attr("x", cfg.subplotWidth/2).attr("y", cfg.marginTop - 20)
      .attr("text-anchor","middle").style("font-weight","bold").style("font-size","18px").style("fill", d=>colorByClass(d));

    classG.selectAll("line.baseline").data([0]).join("line")
      .attr("class","baseline")
      .attr("x1", cfg.baselineX).attr("x2", cfg.baselineX)
      .attr("y1", yTop).attr("y2", yBottom)
      .attr("stroke","#333").attr("stroke-width",2);

    // ---------- Pre-aggregate ----------
    const perClassBins = new Map();
    classes.forEach(cls => {
      const bins = Array.from({length:10}, () => ({TP:[], FP:[], FN:[]}));
      data.forEach(d => {
        const b = binIndex(d.pred_score);
        if (d.true_label === cls && d.pred_label === cls) bins[b].TP.push(d);
        else if (d.pred_label === cls && d.true_label !== cls) bins[b].FP.push(d);
        else if (d.true_label === cls && d.pred_label !== cls) bins[b].FN.push(d);
      });
      perClassBins.set(cls, bins);
    });
    const allTotals = [];
    perClassBins.forEach(bins => bins.forEach(bin => allTotals.push(bin.TP.length + bin.FP.length + bin.FN.length)));
    const maxGlobalBinTotal = Math.max(d3.max(allTotals) ?? 1, 1);

    // ---------- Overflow tooltip helpers ----------
    function showOverflowTooltip(event, arr, type, binIdx){
      if (!arr || !arr.length) return;
      const maxShow = 20;
      const html = `
        <div style="max-width:340px; max-height:260px; overflow-y:auto; font-size:12px;
                    background:#fffbe6; border:2px solid #ff6b35; border-radius:6px;
                    box-shadow:0 2px 8px rgba(0,0,0,0.15); padding:10px;">
          <b>${type} overflow in bin ${binIdx} (showing ${Math.min(maxShow, arr.length)})</b>
          <ul style="margin:6px 0 0 0; padding:0; list-style:none;">
            ${arr.slice(0,maxShow).map(d=>(
              `<li style="margin-bottom:2px;">ID:${d.instance_id} ¬∑ GT:C${d.true_label} ¬∑ Pred:C${d.pred_label} ¬∑ Score:${d.pred_score.toFixed(2)}</li>`
            )).join("")}
          </ul>
          ${arr.length>maxShow? `<div style="color:#e67e22;">‚Ä¶ ${arr.length-maxShow} more</div>` : ""}
        </div>`;
      let el = document.getElementById("overflow-tooltip");
      if (!el) {
        el = document.createElement("div");
        el.id = "overflow-tooltip";
        el.style.position = "fixed";
        el.style.zIndex = 9999;
        document.body.appendChild(el);
      }
      el.innerHTML = html;
      el.style.display = "block";
      el.style.left = (event.clientX + 14) + "px";
      el.style.top  = (event.clientY - 10) + "px";
    }
    function hideOverflowTooltip(){
      const el = document.getElementById("overflow-tooltip");
      if (el) el.style.display = "none";
    }

    // ---------- Draw ----------
    function draw(viewMode="auto"){
      classG.each(function(cls){
        const g = d3.select(this);
        const bins = perClassBins.get(cls);

        const rightWidth = cfg.subplotWidth - cfg.baselineX - 10;
        const leftWidth  = cfg.baselineX - 10;

        const xRight = d3.scaleBand().domain(d3.range(cfg.rowsPerBin)).range([cfg.baselineX, cfg.baselineX + rightWidth]).paddingInner(cfg.spacing / Math.max(1,rightWidth));
        const xLeft  = d3.scaleBand().domain(d3.range(cfg.rowsPerBin)).range([cfg.baselineX - leftWidth, cfg.baselineX]).paddingInner(cfg.spacing / Math.max(1,leftWidth));
        const barWidth = d3.scaleLinear().domain([0, maxGlobalBinTotal]).range([0, rightWidth]).clamp(true);

        const autoShowBoxes = (xRight.bandwidth() >= cfg.minCell) && (yBin.bandwidth() >= cfg.minCell*1.5);
        const showBoxes = (viewMode==="auto") ? autoShowBoxes : (viewMode==="boxes");

        // metrics
        const TP = d3.sum(bins, b => b.TP.length), FP = d3.sum(bins, b => b.FP.length), FN = d3.sum(bins, b => b.FN.length);
        const P = TP/(TP+FP) || 0, R = TP/(TP+FN) || 0, F1 = 2*P*R/(P+R) || 0;

        const metrics = g.selectAll("g.metrics").data([0]).join("g").attr("class","metrics");
        metrics.selectAll("text.c1").data([0]).join("text").attr("class","c1")
          .text(`TP: ${TP}  FP: ${FP}  FN: ${FN}`)
          .attr("x", cfg.subplotWidth/2).attr("y", cfg.svgHeight-80)
          .attr("text-anchor","middle").style("font-size","11px").style("font-weight","600").style("fill","#555");
        metrics.selectAll("text.c2").data([0]).join("text").attr("class","c2")
          .text(`P: ${P.toFixed(2)}  R: ${R.toFixed(2)}  F1: ${F1.toFixed(2)}`)
          .attr("x", cfg.subplotWidth/2).attr("y", cfg.svgHeight-60)
          .attr("text-anchor","middle").style("font-size","11px").style("font-weight","600").style("fill","#555");

        g.selectAll("g.layer").remove();

        if (showBoxes){
          const layer = g.append("g").attr("class","layer boxes");
          const items = [];
          for (let v=9; v>=0; v--){
            const binIdx = v, binTop = yBin(binIdx), binH = yBin.bandwidth();
            const pitchY = Math.max(cfg.minCell, xRight.bandwidth()) + cfg.spacing;

            // ËøáÊª§ÔºàÊåâÂΩìÂâçÁ±ªÁöÑÁ±ªÂûãÔºâ
            const tpAll = bins[binIdx].TP.filter(d => shouldShow(d, "TP"));
            const fpAll = bins[binIdx].FP.filter(d => shouldShow(d, "FP"));
            const fnAll = bins[binIdx].FN.filter(d => shouldShow(d, "FN"));

            const tp = tpAll.slice(0, cfg.maxBoxesPerBinRender);
            const fp = fpAll.slice(0, cfg.maxBoxesPerBinRender);
            const fn = fnAll.slice(0, cfg.maxBoxesPerBinRender);

            const tpOverflow = Math.max(0, tpAll.length - tp.length);
            const fpOverflow = Math.max(0, fpAll.length - fp.length);
            const fnOverflow = Math.max(0, fnAll.length - fn.length);

            // TPÔºàÂè≥‰æßÔºâ
            tp.forEach((d,i)=>{
              const col = i % cfg.rowsPerBin, row = Math.floor(i/cfg.rowsPerBin);
              items.push({key:`TP-${cls}-${binIdx}-${d.instance_id}`, type:"TP", d, x:xRight(col), y:binTop+binH-(row+1)*pitchY, w:xRight.bandwidth(), h:xRight.bandwidth()});
            });
            // FP Êé•Âú® TP Âêé
            const start = Math.min(tpAll.length, cfg.maxBoxesPerBinRender);
            fp.forEach((d,i)=>{
              const k = start + i, col = k % cfg.rowsPerBin, row = Math.floor(k/cfg.rowsPerBin);
              items.push({key:`FP-${cls}-${binIdx}-${d.instance_id}`, type:"FP", d, x:xRight(col), y:binTop+binH-(row+1)*pitchY, w:xRight.bandwidth(), h:xRight.bandwidth()});
            });
            // FNÔºàÂ∑¶‰æßÈïúÂÉèÔºâ
            fn.forEach((d,i)=>{
              const col = i % cfg.rowsPerBin, row = Math.floor(i/cfg.rowsPerBin);
              const x = xLeft(cfg.rowsPerBin-1-col);
              if (x != null) items.push({key:`FN-${cls}-${binIdx}-${d.instance_id}`, type:"FN", d, x, y:binTop+binH-(row+1)*pitchY, w:xLeft.bandwidth(), h:xLeft.bandwidth()});
            });

            // Ê∫¢Âá∫Ê†áËÆ∞
            if (tpOverflow > 0) {
              layer.append("text")
                .attr("x", cfg.baselineX + (cfg.subplotWidth - cfg.baselineX) - 28)
                .attr("y", binTop + 12)
                .attr("fill", colorByClass(cls))
                .style("font-size","12px").style("font-weight","700").style("cursor","pointer")
                .text(`+${tpOverflow}`)
                .on("mouseover", ev => showOverflowTooltip(ev, tpAll.slice(cfg.maxBoxesPerBinRender), "TP", binIdx))
                .on("mouseout", hideOverflowTooltip);
            }
            if (fpOverflow > 0) {
              layer.append("text")
                .attr("x", cfg.baselineX + (cfg.subplotWidth - cfg.baselineX) - 28)
                .attr("y", binTop + 28)
                .attr("fill", "#000")
                .style("font-size","12px").style("font-weight","700").style("cursor","pointer")
                .text(`+${fpOverflow}`)
                .on("mouseover", ev => showOverflowTooltip(ev, fpAll.slice(cfg.maxBoxesPerBinRender), "FP", binIdx))
                .on("mouseout", hideOverflowTooltip);
            }
            if (fnOverflow > 0) {
              layer.append("text")
                .attr("x", 12)
                .attr("y", binTop + 20)
                .attr("fill", colorByClass(cls))
                .style("font-size","12px").style("font-weight","700").style("cursor","pointer")
                .text(`+${fnOverflow}`)
                .on("mouseover", ev => showOverflowTooltip(ev, fnAll.slice(cfg.maxBoxesPerBinRender), "FN", binIdx))
                .on("mouseout", hideOverflowTooltip);
            }
          }

          const rects = layer.selectAll("rect.instance")
            .data(items, d=>d.key)
            .join(
              enter => enter.append("rect").attr("class","instance")
                            .attr("rx",1.5).attr("ry",1.5)
                            .attr("x",d=>d.x).attr("y",d=>d.y)
                            .attr("width",d=>d.w).attr("height",d=>d.h)
                            .style("cursor","pointer"),
              update => update.attr("x",d=>d.x).attr("y",d=>d.y).attr("width",d=>d.w).attr("height",d=>d.h),
              exit => exit.remove()
            )
            .style("opacity", d => bookmarked.has(d.d.instance_id) ? 1 : 0.85)
            .attr("fill", d => d.type==="FN" ? "white" : colorByClass(d.d.true_label))
            .attr("stroke", d => {
              if (bookmarked.has(d.d.instance_id)) return "#ff6b6b";
              if (d.type==="FN") return colorByClass(d.d.pred_label);
              if (d.type==="FP") return "#000";
              return "none";
            })
            .attr("stroke-width", d => bookmarked.has(d.d.instance_id) ? 2.5 : (d.type==="FN"||d.type==="FP") ? 1.2 : 0);

          const tip = d3.select("#tooltip");
          rects.on("mouseover", (ev,dd)=>{
              const d = dd.d;
              tip.style("display","block").html(`${bookmarked.has(d.instance_id)?"‚≠ê ":""}GT: C${d.true_label}<br>Pred: C${d.pred_label}<br>Score: ${d.pred_score.toFixed(3)}`);
              if (polylinesVisible && d.class_scores) showPolyline(d);
            })
            .on("mousemove", ev => tip.style("left",(ev.clientX+12)+"px").style("top",(ev.clientY-10)+"px"))
            .on("mouseout", ()=>{ tip.style("display","none"); if (polylinesVisible) hidePolyline(); })
            .on("click",(ev,dd)=>{ const id=dd.d.instance_id; bookmarked.has(id)?bookmarked.delete(id):bookmarked.add(id); updateBookmarkCount(); draw(viewMode); })
            .on("dblclick",(ev,dd)=> showDetails(dd.d));

        } else {
          const layer = g.append("g").attr("class","layer stacks");
          const bars = [];
          for (let v=9; v>=0; v--){
            const binIdx = v, binY = yBin(binIdx) + (yBin.bandwidth()-16)/2;
            const tp = bins[binIdx].TP.filter(d => shouldShow(d,"TP")).length;
            const fp = bins[binIdx].FP.filter(d => shouldShow(d,"FP")).length;
            const fn = bins[binIdx].FN.filter(d => shouldShow(d,"FN")).length;
            const total = tp+fp+fn, w = barWidth(total);
            let x = cfg.baselineX, fnW = w*(total?fn/total:0), tpW = w*(total?tp/total:0), fpW = w*(total?fp/total:0);
            if (fnW>0) { bars.push({key:`FN-${cls}-${binIdx}`, type:"FN", binIdx, x, y:binY, w:fnW, h:16, total, tp, fp, fn}); x+=fnW; }
            if (tpW>0) { bars.push({key:`TP-${cls}-${binIdx}`, type:"TP", binIdx, x, y:binY, w:tpW, h:16, total, tp, fp, fn}); x+=tpW; }
            if (fpW>0) { bars.push({key:`FP-${cls}-${binIdx}`, type:"FP", binIdx, x, y:binY, w:fpW, h:16, total, tp, fp, fn}); }
          }
          const segs = layer.selectAll("rect.stack")
            .data(bars, d=>d.key)
            .join(
              enter => enter.append("rect").attr("class","stack")
                            .attr("x",d=>d.x).attr("y",d=>d.y)
                            .attr("width",d=>d.w).attr("height",d=>d.h)
                            .style("opacity",0.85),
              update => update.attr("x",d=>d.x).attr("y",d=>d.y).attr("width",d=>d.w).attr("height",d=>d.h),
              exit => exit.remove()
            )
            .attr("fill", d => d.type==="FN" ? "white" : colorByClass(cls))
            .attr("stroke", d => d.type==="FN" ? colorByClass(cls) : (d.type==="FP" ? "#000" : "none"))
            .attr("stroke-width", d => d.type==="FN" ? 1.5 : (d.type==="FP" ? 1.2 : 0));

          const tip = d3.select("#tooltip");
          segs.on("mouseover",(ev,d)=>{
                const lo = (d.binIdx/10).toFixed(1), hi = ((d.binIdx+1)/10).toFixed(1);
                tip.style("display","block").html(`Bin ${d.binIdx} ¬∑ Score: [${lo}, ${hi})<br>Total: ${d.total}<br>TP:${d.tp} FP:${d.fp} FN:${d.fn}`);
              })
              .on("mousemove", ev => tip.style("left",(ev.clientX+12)+"px").style("top",(ev.clientY-10)+"px"))
              .on("mouseout", ()=> tip.style("display","none"));
        }
      });
    }

    // ---------- Polylines ----------
    function showPolyline(inst){
      poly.selectAll("*").remove();
      const pts = (inst.class_scores||[]).map((s,i)=>({
        x: i*cfg.subplotWidth + cfg.classOffset + cfg.yAxisOffset + cfg.baselineX,
        y: yScale(s), score:s, idx:i
      }));
      const line = d3.line().x(d=>d.x).y(d=>d.y);
      poly.append("path").datum(pts).attr("d",line).attr("stroke","#ff6b35").attr("stroke-width",2).attr("fill","none").attr("opacity",0.9).style("pointer-events","none");
      poly.selectAll("circle.dot").data(pts).join("circle").attr("class","dot").attr("cx",d=>d.x).attr("cy",d=>d.y).attr("r",3.5).attr("fill","#ff6b35").attr("stroke","#fff").attr("stroke-width",1).style("pointer-events","none");
    }
    function hidePolyline(){ poly.selectAll("*").remove(); }

    // ---------- Details ----------
    function showDetails(d){
      const scores = d.class_scores ? d.class_scores.map((v,i)=>`C${i}:${v.toFixed(3)}`).join(", ") : "Not available";
      const html = `
        <div style="position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#fff; border:2px solid #333; border-radius:8px; padding:16px; box-shadow:0 4px 16px rgba(0,0,0,0.3); z-index:10000; max-width:520px;">
          <h3 style="margin:0 0 10px 0;">üîç Instance Details</h3>
          <div style="font-size:13px;">
            <p><b>GT:</b> C${d.true_label} &nbsp; <b>Pred:</b> C${d.pred_label} &nbsp; <b>Score:</b> ${d.pred_score.toFixed(3)}</p>
            <p style="word-break:break-all;"><b>All Scores:</b> ${scores}</p>
          </div>
          <div style="text-align:center; margin-top:12px;">
            <button onclick="this.parentElement.parentElement.remove()" class="btn btn-blue">Close</button>
          </div>
        </div>`;
      document.body.insertAdjacentHTML("beforeend", html);
    }

    // ---------- Confusion Report ----------
    function confusionReport(){
      const confusionData = {};
      const classStats = {};
      data.forEach(d=>{
        classStats[d.true_label] ??= {TP:0, FP:0, FN:0, total:0};
        classStats[d.pred_label] ??= {TP:0, FP:0, FN:0, total:0};
        classStats[d.true_label].total++;
        if (d.true_label === d.pred_label) classStats[d.true_label].TP++;
        else {
          classStats[d.true_label].FN++;
          classStats[d.pred_label].FP++;
          const key = `${d.true_label}->${d.pred_label}`;
          confusionData[key] ??= {count:0, scores:[]};
          confusionData[key].count++; confusionData[key].scores.push(d.pred_score);
        }
      });
      const html = `
        <div style="position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#fff; border:2px solid #333; border-radius:8px; padding:16px; box-shadow:0 4px 16px rgba(0,0,0,0.3); z-index:10000; max-width:680px; max-height:70vh; overflow:auto;">
          <h3 style="margin:0 0 10px 0;">üìä Confusion Analysis Report</h3>
          <div style="background:#f8f9fa; padding:10px; border-radius:4px; margin-bottom:10px;">
            <div style="display:grid; grid-template-columns:auto auto auto auto auto; gap:10px; font-size:12px; font-weight:bold; border-bottom:1px solid #ddd; padding-bottom:5px;">
              <div>Class</div><div>Precision</div><div>Recall</div><div>F1</div><div>Support</div>
            </div>
            ${Object.keys(classStats).sort((a,b)=>a-b).map(k=>{
              const s=classStats[k]; const P=s.TP/(s.TP+s.FP)||0, R=s.TP/(s.TP+s.FN)||0, F1=2*P*R/(P+R)||0;
              return `<div style="display:grid; grid-template-columns:auto auto auto auto auto; gap:10px; font-size:12px; padding:3px 0;">
                        <div>C${k}</div><div>${P.toFixed(3)}</div><div>${R.toFixed(3)}</div><div>${F1.toFixed(3)}</div><div>${s.total}</div>
                      </div>`;
            }).join("")}
          </div>
          <div style="background:#fff3cd; padding:10px; border-radius:4px;">
            <h4 style="margin:0 0 6px 0; color:#856404;">‚ö†Ô∏è Top Confusions</h4>
            ${Object.entries(confusionData).sort(([,a],[,b])=>b.count-a.count).slice(0,5).map(([k,v])=>{
              const avg = d3.mean(v.scores)||0;
              return `<div style="margin:6px 0; padding:8px; background:rgba(255,193,7,0.1); border-left:3px solid #ffc107; font-size:12px;">
                        <strong>${k}</strong>: ${v.count} (avg score: ${avg.toFixed(3)})
                      </div>`;
            }).join("")}
          </div>
          <div style="text-align:center; margin-top:12px;">
            <button onclick="this.parentElement.parentElement.remove()" class="btn btn-blue">Close</button>
          </div>
        </div>`;
      document.body.insertAdjacentHTML("beforeend", html);
    }

    // ---------- Controls ----------
    function redraw(){ draw(document.getElementById("view_mode")?.value || "auto"); }
    document.getElementById("view_mode")?.addEventListener("change", redraw);
    document.getElementById("toggle-polylines")?.addEventListener("click", function(){
      polylinesVisible = !polylinesVisible;
      this.textContent = polylinesVisible ? "Hide" : "Show";
      this.classList.toggle("btn-green", !polylinesVisible);
      this.classList.toggle("btn-red", polylinesVisible);
      redraw();
    });
    document.getElementById("clear-bookmarks")?.addEventListener("click", function(){
      bookmarked.clear(); updateBookmarkCount(); redraw();
    });
    document.getElementById("instance-filter")?.addEventListener("change", function(){
      currentFilter = this.value; redraw();
    });
    document.getElementById("confusion-analysis")?.addEventListener("click", confusionReport);

    updateBookmarkCount();
    draw("auto");
  }

  // ---------- ÂêØÂä®Ôºö‰ºòÂÖà‰ΩøÁî®Ê≥®ÂÖ•ÁöÑ JSONÔºõÂê¶ÂàôÁîüÊàêÊºîÁ§∫Êï∞ÊçÆ ----------
 (function boot(){
  const instEl  = document.getElementById('instances-json');
  const namesEl = document.getElementById('classnames-json');

  let instances = null;
  try {
    const txt = instEl ? instEl.textContent.trim() : "";
    instances = txt ? JSON.parse(txt) : null;
  } catch (e) {
    console.error("Failed to parse #instances-json:", e);
    instances = null;
  }

  let classNames = [];
  try {
    const txt = namesEl ? namesEl.textContent.trim() : "";
    classNames = txt ? JSON.parse(txt) : [];
  } catch (e) {
    console.warn("Failed to parse #classnames-json, fallback to empty []:", e);
    classNames = [];
  }

  if (!Array.isArray(instances) || instances.length === 0) {
    const mount = document.getElementById('multi-class-vis');
    if (mount) {
      mount.innerHTML = `
        <div style="text-align:center; padding:40px; color:#666; font-size:14px; background:#fff;">
          <h3 style="margin-top:0;">üö´ Êú™Ê£ÄÊµãÂà∞ÂÆû‰æãÊï∞ÊçÆ</h3>
          <p>ËØ∑Â∞Ü‰Ω†ÁöÑÊï∞ÊçÆÂÜôÂÖ• <code>&lt;script id="instances-json" type="application/json"&gt;...&lt;/script&gt;</code>„ÄÇ</p>
          <p>ÂèØÈÄâÔºöÂ∞ÜÁ±ªÂêçÂÜôÂÖ• <code>&lt;script id="classnames-json" ...&gt;</code>„ÄÇ</p>
        </div>`;
    }
    console.error("No instances provided. Aborting render.");
    return;
  }

  // ÊúâÊï∞ÊçÆÊâçÊ∏≤Êüì
  createClassifierSquaresVisualization(instances, classNames);
})();
  </script>
</body>
</html>
