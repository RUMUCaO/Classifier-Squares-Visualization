<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Classifier Squares D3 Visualization (Scaled & LOD)</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #multi-class-container { width: 100%; min-height: 900px; overflow: auto; border:1px solid #ccc; padding:30px; background:#fafafa; }
    #multi-class-vis svg { display:block; overflow:visible; background:#fff; border-radius:8px; box-shadow:0 4px 8px rgba(0,0,0,0.08); }
    .legend { background:#f8f9fa; border:1px solid #ddd; border-radius:8px; padding:15px; margin-top:20px; font-size:12px; }
    .legend-item { display:inline-block; margin-right:20px; margin-bottom:8px; }
    .legend-color { display:inline-block; width:16px; height:16px; margin-right:5px; vertical-align:middle; border:1px solid #333; }
    .control-panel { margin-top: 20px; padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .axis text { font-size:12px; fill:#333; }
  </style>
</head>
<body>
  <div>
    <label>👁️ View Mode:</label>
    <select id="view_mode">
      <option value="auto" selected>Auto (LOD)</option>
      <option value="boxes">Boxes</option>
      <option value="stacks">Stacks</option>
    </select>
  </div>
  <br>

  <div id="tooltip" style="position:absolute; display:none; background:white; border:1px solid #ccc; padding:6px 8px; pointer-events:none; font-size:12px; z-index:1000; box-shadow:0 2px 4px rgba(0,0,0,0.2); border-radius:4px;"></div>

  <div id="multi-class-container">
    <div id="multi-class-vis"></div>

    <div id="controls" class="control-panel">
      <div style="display:flex; gap:20px; align-items:center; flex-wrap:wrap;">
        <div>
          <label style="font-weight:bold;">🔗 Parallel Coordinates:</label>
          <button id="toggle-polylines" style="margin-left:5px; padding:5px 10px; background:#2ecc71; color:#fff; border:none; border-radius:4px;">Show</button>
          <small style="margin-left:6px; color:#666;">Hover instances to see cross-class scores</small>
        </div>
        <div>
          <label style="font-weight:bold;">⭐ Bookmarks:</label>
          <span id="bookmark-count" style="margin-left:6px; color:#666;">0 instances</span>
          <button id="clear-bookmarks" style="margin-left:10px; padding:5px 10px; background:#e74c3c; color:#fff; border:none; border-radius:4px;">Clear</button>
        </div>
        <div>
          <label style="font-weight:bold;">🔍 Filter:</label>
          <select id="instance-filter" style="margin-left:6px; padding:5px;">
            <option value="all">All Instances</option>
            <option value="bookmarked">Bookmarked Only</option>
            <option value="tp">True Positives (Correct)</option>
            <option value="fp">False Positives (Wrong Pred)</option>
            <option value="fn">False Negatives (Missed)</option>
            <option value="high-Prediction Score">High Prediction Score (>0.8)</option>
            <option value="low-Prediction Score">Low Prediction Score (<0.5)</option>
          </select>
        </div>
        <div>
          <label style="font-weight:bold;">📊 Analysis:</label>
          <button id="confusion-analysis" style="margin-left:6px; padding:5px 10px; background:#3498db; color:#fff; border:none; border-radius:4px;">Confusion Report</button>
        </div>
      </div>
    </div>

    <div class="legend">
      <h4 style="margin:0 0 10px 0; color:#333;">📖 Visualization Legend</h4>
      <div style="display:flex; flex-wrap:wrap; gap:15px;">
        <div class="legend-item">
          <span class="legend-color" style="background:#3498db; border:none;"></span>
          <strong>True Positives (TP):</strong> Colored boxes with no border.
        </div>
        <div class="legend-item">
          <span class="legend-color" style="background:#e74c3c; border:1px solid #333;"></span>
          <strong>False Positives (FP):</strong> Colored fill with border.
        </div>
        <div class="legend-item">
          <span class="legend-color" style="background:white; border:1px solid #3498db;"></span>
          <strong>False Negatives (FN):</strong> White fill with colored border.
        </div>
        <div class="legend-item">
          <span style="display:inline-block; width:16px; height:2px; background:#333; margin-right:5px; vertical-align:middle;"></span>
          <strong>Prediction Score Line:</strong> Vertical baseline.
        </div>
        <div class="legend-item">
          <span style="display:inline-block; width:16px; height:2px; background:#ff6b35; margin-right:5px; vertical-align:middle;"></span>
          <strong>Polylines:</strong> Cross-class score profile (hover).
        </div>
      </div>
    </div>
  </div>

  <script>
  function createClassifierSquaresVisualization(instances, classNames = null, opts = {}) {
    // ---------- Config (no magic numbers) ----------
    const cfg = {
      svgHeight: opts.svgHeight ?? 800,
      subplotWidth: opts.subplotWidth ?? 160,     // 每个类的宽度（含留白）
      classOffset: 60,                            // 左右留白（类组起始偏移）
      yAxisOffset: 45,                            // y 轴离左边的偏移
      marginTop: 50,
      marginBottom: 120,
      baselineX: 25,                              // 基线在每个类子图内部的 x
      spacing: 2,                                 // 方块间距
      minCell: 6,                                 // Boxes 模式可读阈值（像素）
      rowsPerBin: opts.rowsPerBin ?? 30,         // 每行最多放多少格
      maxBoxesPerBinRender: 5000,                // 单 bin 最大渲染实例（Boxes）
    };

    const colors = d3.schemeCategory10;
    const colorByClass = d3.scaleOrdinal(colors);

    // ---------- Data enrich ----------
    let bookmarked = new Set();
    let polylinesVisible = false;
    let currentFilter = "all";
    let instanceIdCounter = 0;

    const data = instances.map(d => {
      const match = (d.true_label === d.pred_label) ? "TP" : "FP"; // FN 在可视化时按类处理
      return {
        ...d,
        match,
        class_focus: d.true_label,             // 每个类面板默认关注 GT 类
        instance_id: instanceIdCounter++,
        class_scores: Array.isArray(d.class_scores) ? d.class_scores : null
      };
    });

    // classes = 所有出现过的类（真值或预测）
    const classSet = Array.from(new Set(data.flatMap(d => [d.true_label, d.pred_label]))).sort((a,b)=>a-b);

    // ---------- Helpers ----------
    function updateBookmarkCount() {
      document.getElementById("bookmark-count").textContent = `${bookmarked.size} instances`;
    }

    function shouldShowInstance(d) {
      if (currentFilter === "bookmarked" && !bookmarked.has(d.instance_id)) return false;
      if (currentFilter === "tp" && d.match !== "TP") return false;
      if (currentFilter === "fp" && d.match !== "FP") return false;
      if (currentFilter === "fn") {
        // “FN”指：在该类面板里为 FN —— 运行时按类判断，这里不过滤
      }
      if (currentFilter === "high-Prediction Score" && d.pred_score < 0.8) return false;
      if (currentFilter === "low-Prediction Score" && d.pred_score >= 0.5) return false;
      return true;
    }

    function binIndexFromScore(s) { return Math.min(Math.floor(s * 10), 9); } // 0..9

    // ---------- SVG ----------
    const svgWidth = Math.max(cfg.subplotWidth * classSet.length + cfg.classOffset + cfg.yAxisOffset + 20, 1200);

    const root = d3.select("#multi-class-vis").html("");
    const svg = root.append("svg")
      .attr("width", svgWidth)
      .attr("height", cfg.svgHeight)
      .attr("viewBox", `0 0 ${svgWidth} ${cfg.svgHeight}`);

    const main = svg.append("g").attr("class", "main-content");
    const polyGroup = svg.append("g").attr("class", "polyline-group");

    // ---------- Scales (global) ----------
    const yTop = cfg.marginTop;
    const yBottom = cfg.svgHeight - cfg.marginBottom;

    const yScale = d3.scaleLinear().domain([0,1]).range([yBottom, yTop]);
    const yBin = d3.scaleBand().domain(d3.range(10)).range([yBottom, yTop]).paddingInner(0.15);

    // y-axis (left, once)
    const yAxis = d3.axisLeft(yScale).ticks(10);
    main.append("g")
      .attr("class", "axis")
      .attr("transform", `translate(${cfg.yAxisOffset},0)`)
      .call(yAxis);
    main.append("text")
      .text("Prediction Score")
      .attr("x", cfg.yAxisOffset - 25)
      .attr("y", cfg.svgHeight/2)
      .attr("text-anchor", "middle")
      .attr("transform", `rotate(-90, ${cfg.yAxisOffset - 25}, ${cfg.svgHeight/2})`)
      .style("font-size","12px")
      .style("font-weight","bold")
      .style("fill","#333");

    // per-class groups
    const classGroups = main.selectAll("g.class")
      .data(classSet, d=>d)
      .join("g")
      .attr("class","class")
      .attr("transform", (cls, i) => `translate(${i * cfg.subplotWidth + cfg.classOffset + cfg.yAxisOffset},0)`);

    // titles + metrics
    classGroups.selectAll("text.title")
      .data(d=>[d])
      .join("text")
      .attr("class","title")
      .text(d => `Class ${d}`)
      .attr("x", cfg.subplotWidth/2)
      .attr("y", cfg.marginTop - 20)
      .attr("text-anchor","middle")
      .style("font-weight","bold")
      .style("font-size","18px")
      .style("fill", d => colorByClass(d));

    // baseline in each class
    classGroups.selectAll("line.baseline")
      .data([0])
      .join("line")
      .attr("class","baseline")
      .attr("x1", cfg.baselineX)
      .attr("x2", cfg.baselineX)
      .attr("y1", yTop)
      .attr("y2", yBottom)
      .attr("stroke", "#333")
      .attr("stroke-width", 2);

    // ---------- Pre-aggregation for stacks + LOD ----------
    // 为每个类统计每个 bin 的 TP/FP/FN 数
    const perClassBins = new Map(); // cls -> [{TP:[], FP:[], FN:[]}, ... (10 bins)]
    classSet.forEach(cls => {
      const bins = Array.from({length: 10}, () => ({TP:[], FP:[], FN:[]}));
      data.forEach(d => {
        const b = binIndexFromScore(d.pred_score);
        if (d.true_label === cls && d.pred_label === cls) bins[b].TP.push(d);
        else if (d.pred_label === cls && d.true_label !== cls) bins[b].FP.push(d);
        else if (d.true_label === cls && d.pred_label !== cls) bins[b].FN.push(d);
      });
      perClassBins.set(cls, bins);
    });

    const allBinTotals = [];
    perClassBins.forEach(bins => {
      bins.forEach(bin => {
        allBinTotals.push(bin.TP.length + bin.FP.length + bin.FN.length);
      });
    });
    const maxGlobalBinTotal = Math.max(d3.max(allBinTotals) ?? 1, 1);

    // ---------- Draw function with LOD ----------
    function draw(viewMode = "auto") {
      // for each class, make x scales (depend on subplotWidth etc.)
      classGroups.each(function(cls){
        const g = d3.select(this);
        const bins = perClassBins.get(cls);

        // 横向 scale（基线右侧 / 左侧镜像）
        const rightWidth = cfg.subplotWidth - cfg.baselineX - 10;
        const leftWidth  = cfg.baselineX - 10;

        const xRight = d3.scaleBand()
          .domain(d3.range(cfg.rowsPerBin))
          .range([cfg.baselineX, cfg.baselineX + rightWidth])
          .paddingInner(cfg.spacing / Math.max(1,rightWidth));

        const xLeft = d3.scaleBand()
          .domain(d3.range(cfg.rowsPerBin))
          .range([cfg.baselineX - leftWidth, cfg.baselineX])
          .paddingInner(cfg.spacing / Math.max(1,leftWidth));

        // 条形宽度（stacks）
        const barWidthScale = d3.scaleLinear()
          .domain([0, maxGlobalBinTotal])
          .range([0, rightWidth])
          .clamp(true);

        // LOD: 自动切换
        const autoShowBoxes = (xRight.bandwidth() >= cfg.minCell) && (yBin.bandwidth() >= cfg.minCell * 1.5);
        const showBoxes = (viewMode === "auto") ? autoShowBoxes : (viewMode === "boxes");

        // ----- metrics -----
        const TP = d3.sum(bins, bin => bin.TP.length);
        const FP = d3.sum(bins, bin => bin.FP.length);
        const FN = d3.sum(bins, bin => bin.FN.length);
        const precision = TP / (TP + FP) || 0;
        const recall = TP / (TP + FN) || 0;
        const f1 = (2 * precision * recall) / (precision + recall) || 0;

        const metrics = g.selectAll("g.metrics").data([0]).join("g").attr("class","metrics");
        metrics.selectAll("text.counts")
          .data([0]).join("text").attr("class","counts")
          .text(`TP: ${TP}  FP: ${FP}  FN: ${FN}`)
          .attr("x", cfg.subplotWidth/2).attr("y", cfg.svgHeight - 80)
          .attr("text-anchor","middle").style("font-size","11px").style("font-weight","600").style("fill","#555");
        metrics.selectAll("text.prf")
          .data([0]).join("text").attr("class","prf")
          .text(`P: ${precision.toFixed(2)}  R: ${recall.toFixed(2)}  F1: ${f1.toFixed(2)}`)
          .attr("x", cfg.subplotWidth/2).attr("y", cfg.svgHeight - 60)
          .attr("text-anchor","middle").style("font-size","11px").style("font-weight","600").style("fill","#555");

        // ----- clear prior layers -----
        g.selectAll("g.layer").remove();

        if (showBoxes) {
          // -------- BOXES LAYER --------
          const layer = g.append("g").attr("class","layer boxes");
          const items = [];

          // 从高分到低分（上->下）
          for (let visualOrder = 9; visualOrder >= 0; visualOrder--) {
            const binIdx = visualOrder;         // 0..9
            const binTop = yBin(binIdx);
            const binH   = yBin.bandwidth();

            // 过滤 + 排序
            const tp = bins[binIdx].TP.filter(shouldShowInstance);
            const fp = bins[binIdx].FP.filter(shouldShowInstance);
            const fn = bins[binIdx].FN.filter(shouldShowInstance);

            // 自下而上堆叠（row 越大 y 越小）
            const pitchY = Math.max(cfg.minCell, xRight.bandwidth()) + cfg.spacing;

            // TP → 右侧
            tp.slice(0, cfg.maxBoxesPerBinRender).forEach((d, i) => {
              const col = i % cfg.rowsPerBin;
              const row = Math.floor(i / cfg.rowsPerBin);
              items.push({
                key: `TP-${cls}-${binIdx}-${d.instance_id}`,
                type: "TP", d, cls, binIdx,
                x: xRight(col),
                y: binTop + binH - (row + 1) * pitchY,
                w: xRight.bandwidth(), h: xRight.bandwidth()
              });
            });
            // FP 接在 TP 后面 → 右侧
            const start = Math.min(tp.length, cfg.maxBoxesPerBinRender);
            fp.slice(0, cfg.maxBoxesPerBinRender).forEach((d, i) => {
              const k = start + i;
              const col = k % cfg.rowsPerBin;
              const row = Math.floor(k / cfg.rowsPerBin);
              items.push({
                key: `FP-${cls}-${binIdx}-${d.instance_id}`,
                type: "FP", d, cls, binIdx,
                x: xRight(col),
                y: binTop + binH - (row + 1) * pitchY,
                w: xRight.bandwidth(), h: xRight.bandwidth()
              });
            });

            // FN → 左侧（镜像，从基线向左扩展）
            fn.slice(0, cfg.maxBoxesPerBinRender).forEach((d, i) => {
              const col = i % cfg.rowsPerBin;
              const row = Math.floor(i / cfg.rowsPerBin);
              const x = xLeft(cfg.rowsPerBin - 1 - col);
              if (x != null) {
                items.push({
                  key: `FN-${cls}-${binIdx}-${d.instance_id}`,
                  type: "FN", d, cls, binIdx,
                  x: x,
                  y: binTop + binH - (row + 1) * pitchY,
                  w: xLeft.bandwidth(), h: xLeft.bandwidth()
                });
              }
            });
          }

          // --- draw with selection.join ---
          const rects = layer.selectAll("rect.instance")
            .data(items, d => d.key)
            .join(
              enter => enter.append("rect")
                           .attr("class","instance")
                           .attr("rx", 1.5).attr("ry", 1.5)
                           .attr("x", d=>d.x).attr("y", d=>d.y)
                           .attr("width", d=>d.w).attr("height", d=>d.h)
                           .style("cursor","pointer"),
              update => update
                         .attr("x", d=>d.x).attr("y", d=>d.y)
                         .attr("width", d=>d.w).attr("height", d=>d.h),
              exit => exit.remove()
            )
            .style("opacity", d => bookmarked.has(d.d.instance_id) ? 1 : 0.85)
            .attr("fill", d => {
              if (d.type === "FN") return "white";
              return colorByClass(d.type === "TP" ? d.d.true_label : d.d.true_label);
            })
            .attr("stroke", d => {
              if (bookmarked.has(d.d.instance_id)) return "#ff6b6b";
              if (d.type === "FN") return colorByClass(d.d.pred_label);
              if (d.type === "FP") return "#000";
              return "none";
            })
            .attr("stroke-width", d => (bookmarked.has(d.d.instance_id) ? 2.5 : (d.type === "FP" || d.type === "FN") ? 1.2 : 0));

          // tooltip + bookmark + polyline
          const tip = d3.select("#tooltip");
          rects
            .on("mouseover", (ev, dd) => {
              const d = dd.d;
              tip.style("display","block").html(`
                ${bookmarked.has(d.instance_id) ? "⭐ " : ""}GT: C${d.true_label}<br>
                Pred: C${d.pred_label}<br>
                Score: ${d.pred_score.toFixed(3)}
              `);
              if (polylinesVisible && d.class_scores) showInstancePolyline(d);
            })
            .on("mousemove", (ev) => {
              tip.style("left", (ev.clientX + 12) + "px").style("top", (ev.clientY - 10) + "px");
            })
            .on("mouseout", () => {
              tip.style("display","none");
              if (polylinesVisible) hideInstancePolyline();
            })
            .on("click", (ev, dd) => {
              const id = dd.d.instance_id;
              if (bookmarked.has(id)) bookmarked.delete(id); else bookmarked.add(id);
              updateBookmarkCount();
              draw(viewMode); // refresh styles
            })
            .on("dblclick", (ev, dd) => {
              showEnhancedInstanceDetails(dd.d);
            });

        } else {
          // -------- STACKS LAYER --------
          const layer = g.append("g").attr("class","layer stacks");

          // 每个 bin 一条横条，内部分段：FN | TP | FP
          const bars = [];
          for (let visualOrder = 9; visualOrder >= 0; visualOrder--) {
            const binIdx = visualOrder;
            const binY = yBin(binIdx) + (yBin.bandwidth() - 16) / 2;

            const tpCount = bins[binIdx].TP.filter(shouldShowInstance).length;
            const fpCount = bins[binIdx].FP.filter(shouldShowInstance).length;
            const fnCount = bins[binIdx].FN.filter(shouldShowInstance).length;
            const total = tpCount + fpCount + fnCount;

            const w = barWidthScale(total);
            let xStart = cfg.baselineX;

            const fnW = w * (total ? fnCount/total : 0);
            const tpW = w * (total ? tpCount/total : 0);
            const fpW = w * (total ? fpCount/total : 0);

            if (fnW > 0) bars.push({key:`FN-${cls}-${binIdx}`, type:"FN", x:xStart, y:binY, w:fnW, h:16, tp:tpCount, fp:fpCount, fn:fnCount, total});
            xStart += fnW;
            if (tpW > 0) bars.push({key:`TP-${cls}-${binIdx}`, type:"TP", x:xStart, y:binY, w:tpW, h:16, tp:tpCount, fp:fpCount, fn:fnCount, total});
            xStart += tpW;
            if (fpW > 0) bars.push({key:`FP-${cls}-${binIdx}`, type:"FP", x:xStart, y:binY, w:fpW, h:16, tp:tpCount, fp:fpCount, fn:fnCount, total});
          }

          const segs = layer.selectAll("rect.stack")
            .data(bars, d=>d.key)
            .join(
              enter => enter.append("rect").attr("class","stack")
                            .attr("x", d=>d.x).attr("y", d=>d.y)
                            .attr("width", d=>d.w).attr("height", d=>d.h)
                            .style("opacity", 0.85),
              update => update.attr("x", d=>d.x).attr("y", d=>d.y)
                              .attr("width", d=>d.w).attr("height", d=>d.h),
              exit => exit.remove()
            )
            .attr("fill", d => {
              if (d.type === "FN") return "white";
              if (d.type === "TP") return colorByClass(cls);
              return colorByClass(cls);
            })
            .attr("stroke", d => d.type === "FN" ? colorByClass(cls) : (d.type === "FP" ? "#000" : "none"))
            .attr("stroke-width", d => d.type === "FN" ? 1.5 : (d.type === "FP" ? 1.2 : 0));

          const tip = d3.select("#tooltip");
          segs.on("mouseover", (ev, d) => {
              tip.style("display","block").html(
                `Bin ${d.key.split("-").pop()}<br>Total: ${d.total}<br>TP:${d.tp} FP:${d.fp} FN:${d.fn}`
              );
            })
            .on("mousemove", (ev) => {
              tip.style("left", (ev.clientX + 12) + "px").style("top", (ev.clientY - 10) + "px");
            })
            .on("mouseout", () => tip.style("display","none"));
        }
      });
    } // draw

    // ---------- Polylines (hover profile) ----------
    function showInstancePolyline(inst) {
      polyGroup.selectAll("*").remove();

      const pts = (inst.class_scores || []).map((score, i) => {
        const x = i * cfg.subplotWidth + cfg.classOffset + cfg.yAxisOffset + cfg.baselineX;
        const y = yScale(score);
        return {x, y, score, idx:i};
      });

      const line = d3.line().x(d=>d.x).y(d=>d.y);
      polyGroup.append("path")
        .datum(pts)
        .attr("d", line)
        .attr("stroke", "#ff6b35")
        .attr("stroke-width", 2)
        .attr("fill", "none")
        .attr("opacity", 0.9)
        .style("pointer-events","none");

      polyGroup.selectAll("circle.dot")
        .data(pts)
        .join("circle")
        .attr("class","dot")
        .attr("cx", d=>d.x)
        .attr("cy", d=>d.y)
        .attr("r", 3.5)
        .attr("fill", "#ff6b35")
        .attr("stroke", "#fff")
        .attr("stroke-width", 1)
        .style("pointer-events","none");
    }
    function hideInstancePolyline(){ polyGroup.selectAll("*").remove(); }

    // ---------- Confusion report ----------
    function generateConfusionReport() {
      const confusionData = {};
      const classStats = {};
      data.forEach(d => {
        classStats[d.true_label] ??= {TP:0, FP:0, FN:0, total:0};
        classStats[d.pred_label] ??= {TP:0, FP:0, FN:0, total:0};
        classStats[d.true_label].total++;
        if (d.true_label === d.pred_label) {
          classStats[d.true_label].TP++;
        } else {
          classStats[d.true_label].FN++;
          classStats[d.pred_label].FP++;
          const key = `${d.true_label}->${d.pred_label}`;
          confusionData[key] ??= {count:0, scores:[]};
          confusionData[key].count++;
          confusionData[key].scores.push(d.pred_score);
        }
      });
      const tipHTML = `
        <div style="position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
                    background:#fff; border:2px solid #333; border-radius:8px; padding:20px;
                    box-shadow:0 4px 16px rgba(0,0,0,0.3); z-index:10000; max-width:640px; max-height:70vh; overflow:auto;">
          <h3 style="margin:0 0 12px 0;">📊 Confusion Analysis Report</h3>
          <div style="background:#f8f9fa; padding:12px; border-radius:4px; margin-bottom:12px;">
            <div style="display:grid; grid-template-columns:auto auto auto auto auto; gap:10px; font-size:12px; font-weight:bold; border-bottom:1px solid #ddd; padding-bottom:5px;">
              <div>Class</div><div>Precision</div><div>Recall</div><div>F1</div><div>Support</div>
            </div>
            ${Object.keys(classStats).sort((a,b)=>a-b).map(cls=>{
              const s = classStats[cls];
              const P = s.TP / (s.TP + s.FP) || 0;
              const R = s.TP / (s.TP + s.FN) || 0;
              const F1 = 2*P*R/(P+R) || 0;
              return `<div style="display:grid; grid-template-columns:auto auto auto auto auto; gap:10px; font-size:12px; padding:3px 0;">
                        <div>C${cls}</div><div>${P.toFixed(3)}</div><div>${R.toFixed(3)}</div><div>${F1.toFixed(3)}</div><div>${s.total}</div>
                      </div>`;
            }).join("")}
          </div>
          <div style="background:#fff3cd; padding:12px; border-radius:4px;">
            <h4 style="margin:0 0 8px 0; color:#856404;">⚠️ Top Confusion Patterns</h4>
            ${Object.entries(confusionData).sort(([,a],[,b])=>b.count-a.count).slice(0,5).map(([k,v])=>{
              const avg = d3.mean(v.scores) ?? 0;
              return `<div style="margin:6px 0; padding:8px; background:rgba(255,193,7,0.1); border-left:3px solid #ffc107; font-size:12px;">
                        <strong>${k}</strong>: ${v.count} instances (avg score: ${avg.toFixed(3)})
                      </div>`;
            }).join("")}
          </div>
          <div style="text-align:center; margin-top:16px;">
            <button onclick="this.parentElement.parentElement.remove()"
                    style="padding:8px 16px; background:#007bff; color:#fff; border:none; border-radius:4px;">Close</button>
          </div>
        </div>`;
      document.body.insertAdjacentHTML("beforeend", tipHTML);
    }

    // ---------- Controls ----------
    const selector = document.getElementById("view_mode");
    const btnPoly = document.getElementById("toggle-polylines");
    const btnClear = document.getElementById("clear-bookmarks");
    const selFilter = document.getElementById("instance-filter");
    const btnReport = document.getElementById("confusion-analysis");

    function redraw() { draw(selector ? selector.value : "auto"); }

    selector?.addEventListener("change", redraw);
    btnPoly?.addEventListener("click", function(){
      polylinesVisible = !polylinesVisible;
      this.textContent = polylinesVisible ? "Hide" : "Show";
      this.style.background = polylinesVisible ? "#e74c3c" : "#2ecc71";
      redraw();
    });
    btnClear?.addEventListener("click", function(){
      bookmarked.clear();
      updateBookmarkCount();
      redraw();
    });
    selFilter?.addEventListener("change", function(){
      currentFilter = this.value;
      redraw();
    });
    btnReport?.addEventListener("click", generateConfusionReport);

    updateBookmarkCount();
    draw("auto"); // initial
  }

  // expose to global
  window.createClassifierSquaresVisualization = createClassifierSquaresVisualization;

  // Placeholder content (if user hasn't called the function yet)
  document.getElementById("multi-class-vis").innerHTML = `
    <div style="text-align:center; padding:50px; color:#666; font-size:16px;">
      <h3>🎯 Classifier Squares Visualization (Scaled & LOD)</h3>
      <p>This visualization is ready for your classification results.</p>
      <p><strong>Use:</strong></p>
      <ol style="text-align:left; max-width:620px; margin:20px auto;">
        <li>Prepare data: <code>[{true_label:0, pred_label:1, pred_score:0.85, class_scores:[...]}, ...]</code></li>
        <li>Call: <code>createClassifierSquaresVisualization(instances)</code></li>
      </ol>
    </div>
  `;
  </script>
</body>
</html>
