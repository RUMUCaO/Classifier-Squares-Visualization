<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Classifier Squares D3 Visualization (Scaled & LOD)</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #multi-class-container { width: 100%; min-height: 900px; overflow: auto; border:1px solid #ccc; padding:30px; background:#fafafa; }
    #multi-class-vis svg { display:block; overflow:visible; background:#fff; border-radius:8px; box-shadow:0 4px 8px rgba(0,0,0,0.08); }
    .legend { background:#f8f9fa; border:1px solid #ddd; border-radius:8px; padding:15px; margin-top:20px; font-size:12px; }
    .legend-item { display:inline-block; margin-right:20px; margin-bottom:8px; }
    .legend-color { display:inline-block; width:16px; height:16px; margin-right:5px; vertical-align:middle; border:1px solid #333; }
    .control-panel { margin-top: 20px; padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .axis text { font-size:12px; fill:#333; }
    .btn { padding:5px 10px; border:none; border-radius:4px; color:#fff; cursor:pointer; }
    .btn-green { background:#2ecc71; }
    .btn-red { background:#e74c3c; }
    .btn-blue { background:#3498db; }
  </style>
</head>
<body>
  <div>
    <label>üëÅÔ∏è View Mode:</label>
    <select id="view_mode">
      <option value="auto" selected>Auto (LOD)</option>
      <option value="boxes">Boxes</option>
      <option value="stacks">Stacks</option>
    </select>
  </div>
  <br>

  <div id="tooltip" style="position:absolute; display:none; background:white; border:1px solid #ccc; padding:6px 8px; pointer-events:none; font-size:12px; z-index:1000; box-shadow:0 2px 4px rgba(0,0,0,0.2); border-radius:4px;"></div>

  <div id="multi-class-container">
    <div id="multi-class-vis"></div>

    <div id="controls" class="control-panel">
      <div style="display:flex; gap:20px; align-items:center; flex-wrap:wrap;">
        <div>
          <label style="font-weight:bold;">üîó Parallel Coordinates:</label>
          <button id="toggle-polylines" class="btn btn-green" style="margin-left:6px;">Show</button>
          <small style="margin-left:6px; color:#666;">Hover instances to see cross-class scores</small>
        </div>
        <div>
          <label style="font-weight:bold;">‚≠ê Bookmarks:</label>
          <span id="bookmark-count" style="margin-left:6px; color:#666;">0 instances</span>
          <button id="clear-bookmarks" class="btn btn-red" style="margin-left:10px;">Clear</button>
        </div>
        <div>
          <label style="font-weight:bold;">üîç Filter:</label>
          <select id="instance-filter" style="margin-left:6px; padding:5px;">
            <option value="all">All Instances</option>
            <option value="bookmarked">Bookmarked Only</option>
            <option value="tp">True Positives (Correct)</option>
            <option value="fp">False Positives (Wrong Pred)</option>
            <option value="fn">False Negatives (Missed)</option>
            <option value="high-Prediction Score">High Prediction Score (>0.8)</option>
            <option value="low-Prediction Score">Low Prediction Score (<0.5)</option>
          </select>
        </div>
        <div>
          <label style="font-weight:bold;">üìä Analysis:</label>
          <button id="confusion-analysis" class="btn btn-blue" style="margin-left:6px;">Confusion Report</button>
        </div>
      </div>
    </div>

    <div class="legend">
      <h4 style="margin:0 0 10px 0; color:#333;">üìñ Visualization Legend</h4>
      <div style="display:flex; flex-wrap:wrap; gap:15px;">
        <div class="legend-item"><span class="legend-color" style="background:#3498db; border:none;"></span><strong>TP (True Positives)</strong>: Correctly classified - colored box, no border</div>
        <div class="legend-item"><span class="legend-color" style="background:#e74c3c; border:1px solid black;"></span><strong>FP (False Positives)</strong>: Incorrectly classified as this class - colored fill + black border</div>
        <div class="legend-item"><span class="legend-color" style="background:white; border:1px solid #3498db;"></span><strong>FN (False Negatives)</strong>: Should belong to this class but missed - white fill + colored border</div>
        <div class="legend-item"><span style="display:inline-block; width:16px; height:2px; background:#333; margin-right:5px; vertical-align:middle;"></span><strong>Baseline</strong></div>
        <div class="legend-item"><span style="display:inline-block; width:16px; height:2px; background:#ff6b35; margin-right:5px; vertical-align:middle;"></span><strong>Polyline</strong></div>
      </div>
    </div>
  </div>

  <!-- External data injection containers (optional) -->
  <script id="instances-json" type="application/json"></script>
  <script id="classnames-json" type="application/json"></script>

  <script>
  function createClassifierSquaresVisualization(instances, classNames = null, opts = {}) {
    // ---------- Config ----------
    const cfg = {
      svgHeight: opts.svgHeight ?? 800,
      subplotWidth: opts.subplotWidth ?? 200,  // Reduced width for more compact layout
      classOffset: 45,
      yAxisOffset: 45,
      marginTop: 50,
      marginBottom: 120,
      baselineX: 85,  // Maximum baseline position for optimal FN space
      spacing: 2,
      minCell: 12,
      maxCell: opts.maxCell ?? 24,
      rowsPerBin: opts.rowsPerBin ?? 8,
      fnSingleRow: opts.fnSingleRow ?? false,   // Key: Fix FN to single row on left side
      maxBoxesPerBinRender: 5000,
    };
    const colors = d3.schemeCategory10;
    const colorByClass = d3.scaleOrdinal(colors);

    // ---------- State ----------
    let bookmarked = new Set();
    let polylinesVisible = false;
    let currentFilter = "all";
    let iid = 0;

    // Data cleaning
    const data = instances.map(d => ({
      true_label: +d.true_label,
      pred_label: +d.pred_label,
      pred_score: +d.pred_score,
      class_scores: Array.isArray(d.class_scores) ? d.class_scores.map(Number) : null,
      match: d.true_label === d.pred_label ? "TP" : "FP",
      class_focus: +d.true_label,
      instance_id: iid++
    }));

    const classes = Array.from(new Set(data.flatMap(d => [d.true_label, d.pred_label]))).sort((a,b)=>a-b);

    function updateBookmarkCount(){
      document.getElementById("bookmark-count").textContent = `${bookmarked.size} instances`;
    }

    function shouldShow(d, typeForThisClass) {
      switch (currentFilter) {
        case "bookmarked": return bookmarked.has(d.instance_id);
        case "tp":         return typeForThisClass === "TP";
        case "fp":         return typeForThisClass === "FP";
        case "fn":         return typeForThisClass === "FN";
        case "high-Prediction Score": return d.pred_score >= 0.8;
        case "low-Prediction Score":  return d.pred_score < 0.5;
        default: return true;
      }
    }
    function binIndex(s){ return Math.min(Math.floor(s*10), 9); }

    // ---------- SVG ----------
    const svgWidth = Math.max(cfg.subplotWidth * classes.length + cfg.classOffset + cfg.yAxisOffset + 20, 1000);
    const root = d3.select("#multi-class-vis").html("");
    const svg = root.append("svg").attr("width", svgWidth).attr("height", cfg.svgHeight).attr("viewBox", `0 0 ${svgWidth} ${cfg.svgHeight}`);
    const main = svg.append("g").attr("class", "main");
    const poly = svg.append("g").attr("class", "polyline");

    const yTop = cfg.marginTop, yBottom = cfg.svgHeight - cfg.marginBottom;
    const yScale = d3.scaleLinear().domain([0,1]).range([yBottom, yTop]);
    const yBin = d3.scaleBand().domain(d3.range(10)).range([yBottom, yTop]).paddingInner(0.15);

    main.append("g").attr("class","axis").attr("transform", `translate(${cfg.yAxisOffset},0)`).call(d3.axisLeft(yScale).ticks(10));
    main.append("text").text("Prediction Score")
      .attr("x", cfg.yAxisOffset - 25).attr("y", cfg.svgHeight/2)
      .attr("text-anchor","middle").attr("transform", `rotate(-90, ${cfg.yAxisOffset - 25}, ${cfg.svgHeight/2})`)
      .style("font-size","12px").style("font-weight","bold").style("fill","#333");

    const classG = main.selectAll("g.cls")
      .data(classes, d=>d)
      .join("g")
      .attr("class","cls")
      .attr("transform", (cls, i) => `translate(${i*cfg.subplotWidth + cfg.classOffset + cfg.yAxisOffset},0)`);

    classG.selectAll("text.title")
      .data(d=>[d]).join("text")
      .attr("class","title")
      .text(d => (classNames && classNames[d]) ? `C${d} ¬∑ ${classNames[d]}` : `Class ${d}`)
      .attr("x", cfg.subplotWidth/2).attr("y", cfg.marginTop - 20)
      .attr("text-anchor","middle").style("font-weight","bold").style("font-size","18px").style("fill", d=>colorByClass(d));

    classG.selectAll("line.baseline").data([0]).join("line")
      .attr("class","baseline")
      .attr("x1", cfg.baselineX).attr("x2", cfg.baselineX)
      .attr("y1", yTop).attr("y2", yBottom)
      .attr("stroke","#333").attr("stroke-width",2);

    // ---------- Pre-aggregate ----------
    const perClassBins = new Map();
    classes.forEach(cls => {
      const bins = Array.from({length:10}, () => ({TP:[], FP:[], FN:[]}));
      data.forEach(d => {
        const b = binIndex(d.pred_score);
        if (d.true_label === cls && d.pred_label === cls) bins[b].TP.push(d);
        else if (d.pred_label === cls && d.true_label !== cls) bins[b].FP.push(d);
        else if (d.true_label === cls && d.pred_label !== cls) bins[b].FN.push(d);
      });
      perClassBins.set(cls, bins);
    });
    const allTotals = [];
    perClassBins.forEach(bins => bins.forEach(bin => allTotals.push(bin.TP.length + bin.FP.length + bin.FN.length)));
    const maxGlobalBinTotal = Math.max(d3.max(allTotals) ?? 1, 1);

    // ---------- Overflow tooltip helpers ----------
    function showOverflowTooltip(event, arr, type, binIdx){
      if (!arr || !arr.length) return;
      const maxShow = 20;
      const html = `
        <div style="max-width:340px; max-height:260px; overflow-y:auto; font-size:12px;
                    background:#fffbe6; border:2px solid #ff6b35; border-radius:6px;
                    box-shadow:0 2px 8px rgba(0,0,0,0.15); padding:10px;">
          <b>${type} overflow in bin ${binIdx} (showing ${Math.min(maxShow, arr.length)})</b>
          <ul style="margin:6px 0 0 0; padding:0; list-style:none;">
            ${arr.slice(0,maxShow).map(d=>(`<li style="margin-bottom:2px;">ID:${d.instance_id} ¬∑ GT:C${d.true_label} ¬∑ Pred:C${d.pred_label} ¬∑ Score:${d.pred_score.toFixed(2)}</li>`)).join("")}
          </ul>
          ${arr.length>maxShow? `<div style="color:#e67e22;">‚Ä¶ ${arr.length-maxShow} more</div>` : ""}
        </div>`;
      let el = document.getElementById("overflow-tooltip");
      if (!el) {
        el = document.createElement("div");
        el.id = "overflow-tooltip";
        el.style.position = "fixed";
        el.style.zIndex = 9999;
        document.body.appendChild(el);
      }
      el.innerHTML = html;
      el.style.display = "block";
      el.style.left = (event.clientX + 14) + "px";
      el.style.top  = (event.clientY - 10) + "px";
    }
    function hideOverflowTooltip(){
      const el = document.getElementById("overflow-tooltip");
      if (el) el.style.display = "none";
    }

    // ---------- Draw ----------
    function draw(viewMode="auto"){
      classG.each(function(cls){
        const g = d3.select(this);
        const bins = perClassBins.get(cls);

        const rightWidth = cfg.subplotWidth - cfg.baselineX - 10;
        const leftWidth  = cfg.baselineX - 2;  // Maximize left side space

        // Detect LOD (only for switching decision)
        const xRightProbe = d3.scaleBand().domain(d3.range(cfg.rowsPerBin)).range([cfg.baselineX, cfg.baselineX + rightWidth]);
        const xLeftProbe  = d3.scaleBand().domain(d3.range(cfg.rowsPerBin)).range([cfg.baselineX - leftWidth, cfg.baselineX]);
        const cellProbe   = Math.max(cfg.minCell, Math.floor(Math.min(xRightProbe.bandwidth(), xLeftProbe.bandwidth())));
        const autoShowBoxes = (cellProbe >= cfg.minCell) && (yBin.bandwidth() >= cfg.minCell * 1.2);
        const showBoxes = (viewMode==="auto") ? autoShowBoxes : (viewMode==="boxes");

        const barWidth = d3.scaleLinear().domain([0, maxGlobalBinTotal]).range([0, rightWidth]).clamp(true);

        // metrics
        const TP = d3.sum(bins, b => b.TP.length), FP = d3.sum(bins, b => b.FP.length), FN = d3.sum(bins, b => b.FN.length);
        const P = TP/(TP+FP) || 0, R = TP/(TP+FN) || 0, F1 = 2*P*R/(P+R) || 0;

        const metrics = g.selectAll("g.metrics").data([0]).join("g").attr("class","metrics");
        metrics.selectAll("text.c1").data([0]).join("text").attr("class","c1")
          .text(`TP: ${TP}  FP: ${FP}  FN: ${FN}`)
          .attr("x", cfg.subplotWidth/2).attr("y", cfg.svgHeight-80)
          .attr("text-anchor","middle").style("font-size","11px").style("font-weight","600").style("fill","#555");
        metrics.selectAll("text.c2").data([0]).join("text").attr("class","c2")
          .text(`P: ${P.toFixed(2)}  R: ${R.toFixed(2)}  F1: ${F1.toFixed(2)}`)
          .attr("x", cfg.subplotWidth/2).attr("y", cfg.svgHeight-60)
          .attr("text-anchor","middle").style("font-size","11px").style("font-weight","600").style("fill","#555");

        g.selectAll("g.layer").remove();

        if (showBoxes){
          const layer = g.append("g").attr("class","layer boxes");

          // ‚Äî‚Äî Calculate cell size with collision prevention ‚Äî‚Äî //
          const colsTarget = Math.max(1, cfg.rowsPerBin);
          
          // Ensure minimum spacing from edges to prevent collision
          const rightSafeWidth = rightWidth - 20; // Reserve 20px on right
          const leftSafeWidth = leftWidth - 5;    // Minimize left reserve for maximum FN space
          
          const cellR_byRows = Math.floor((rightSafeWidth - (colsTarget - 1) * cfg.spacing) / colsTarget);
          const cellL_byRows = Math.floor((leftSafeWidth  - (colsTarget - 1) * cfg.spacing) / colsTarget);
          const cell = Math.max(cfg.minCell, Math.min(cellR_byRows, cellL_byRows, cfg.maxCell));
          const stepX = cell + cfg.spacing;
          const stepY = cell + cfg.spacing;

          const colsR = Math.max(1, Math.min(colsTarget, Math.floor((rightSafeWidth + cfg.spacing) / stepX)));
          // Left side column calculation with safe boundaries
          const colsL = Math.max(1, Math.min(colsTarget, Math.floor((leftSafeWidth + cfg.spacing) / stepX)));

          const items = [];
          for (let v=9; v>=0; v--){
            const binIdx = v, binTop = yBin(binIdx), binH = yBin.bandwidth();

            // Max rows available on right; if single row on left, fix to 1 row
            const maxRowsRight = Math.max(1, Math.floor(binH / stepY));
            const maxRowsLeft  = cfg.fnSingleRow ? 1 : maxRowsRight;

            const capRight = colsR * maxRowsRight;      // TP+FP capacity
            const capLeft  = colsL * maxRowsLeft;       // FN capacity uses left column count

            // Filtering
            const tpAll = bins[binIdx].TP.filter(d => shouldShow(d, "TP"));
            const fpAll = bins[binIdx].FP.filter(d => shouldShow(d, "FP"));
            const fnAll = bins[binIdx].FN.filter(d => shouldShow(d, "FN"));

            // Capacity trimming: TP first, then FP; FN single row trimming
            const tp = tpAll.slice(0, Math.min(capRight, cfg.maxBoxesPerBinRender));
            const fp = fpAll.slice(0, Math.min(Math.max(0, capRight - tp.length), Math.max(0, cfg.maxBoxesPerBinRender - tp.length)));
            const fn = fnAll.slice(0, Math.min(capLeft, cfg.maxBoxesPerBinRender));

            const tpOverflow = Math.max(0, tpAll.length - tp.length);
            const fpOverflow = Math.max(0, fpAll.length - fp.length);
            const fnOverflow = Math.max(0, fnAll.length - fn.length);

            // --- TP (right side, grid layout) ---
            tp.forEach((d,i)=>{
              const col = i % colsR, row = Math.floor(i / colsR);
              const x = Math.round(cfg.baselineX + col * stepX);
              const y = Math.round(binTop + binH - (row + 1) * stepY);
              items.push({key:`TP-${cls}-${binIdx}-${d.instance_id}`, type:"TP", d, x, y, w:cell, h:cell});
            });

            // --- FP (following TP) ---
            const start = Math.min(tpAll.length, cfg.maxBoxesPerBinRender);
            fp.forEach((d,i)=>{
              const k = start + i;
              const col = k % colsR, row = Math.floor(k / colsR);
              const x = Math.round(cfg.baselineX + col * stepX);
              const y = Math.round(binTop + binH - (row + 1) * stepY);
              items.push({key:`FP-${cls}-${binIdx}-${d.instance_id}`, type:"FP", d, x, y, w:cell, h:cell});
            });

            // --- FN (left side, multi-row arrangement with boundary protection) ---
            fn.forEach((d,i)=>{
              const col = i % colsL, row = Math.floor(i / colsL); // Use left column count
              const x = Math.round(cfg.baselineX - (col + 1) * stepX);
              const y = Math.round(binTop + binH - (row + 1) * stepY);
              // Ensure FN doesn't go beyond left boundary (protect from adjacent class collision)
              const minX = 3; // Reduced minimum left margin for more space
              const safeX = Math.max(minX, x);
              items.push({key:`FN-${cls}-${binIdx}-${d.instance_id}`, type:"FN", d, x:safeX, y, w:cell, h:cell});
            });

            // Overflow markers with better positioning
            if (tpOverflow > 0) {
              const overflowX = Math.min(cfg.subplotWidth - 35, cfg.baselineX + colsR * stepX + 5);
              layer.append("text")
                .attr("x", overflowX)
                .attr("y", binTop + 12)
                .attr("fill", "#3498db")
                .style("font-size","11px").style("font-weight","700").style("cursor","pointer")
                .style("text-anchor", "start")
                .text(`+${tpOverflow}`)
                .on("mouseover", ev => showOverflowTooltip(ev, tpAll.slice(cfg.maxBoxesPerBinRender), "TP", binIdx))
                .on("mouseout", hideOverflowTooltip);
            }
            if (fpOverflow > 0) {
              const overflowX = Math.min(cfg.subplotWidth - 35, cfg.baselineX + colsR * stepX + 5);
              layer.append("text")
                .attr("x", overflowX)
                .attr("y", binTop + 26)
                .attr("fill", "#e74c3c")
                .style("font-size","11px").style("font-weight","700").style("cursor","pointer")
                .style("text-anchor", "start")
                .text(`+${fpOverflow}`)
                .on("mouseover", ev => showOverflowTooltip(ev, fpAll.slice(cfg.maxBoxesPerBinRender), "FP", binIdx))
                .on("mouseout", hideOverflowTooltip);
            }
            if (fnOverflow > 0) {
              // FN overflow marker positioned at fixed left position
              const fnOverflowX = -10; // Fixed position at left edge
              layer.append("text")
                .attr("x", fnOverflowX)
                .attr("y", binTop + binH/2)
                .attr("fill", colorByClass(cls))
                .style("font-size","10px").style("font-weight","700").style("cursor","pointer")
                .style("text-anchor", "start")
                .text(`+${fnOverflow}`)
                .on("mouseover", ev => showOverflowTooltip(ev, fnAll.slice(cfg.maxBoxesPerBinRender), "FN", binIdx))
                .on("mouseout", hideOverflowTooltip);
            }
          }

          // Unified rendering (pixel aligned)
          const rects = layer.selectAll("rect.instance")
            .data(items, d=>d.key)
            .join(
              enter => enter.append("rect").attr("class","instance")
                            .attr("shape-rendering","crispEdges")
                            .attr("vector-effect","non-scaling-stroke")
                            .attr("rx",3).attr("ry",3)
                            .attr("x",d=>d.x).attr("y",d=>d.y)
                            .attr("width",d=>d.w).attr("height",d=>d.h)
                            .style("cursor","pointer"),
              update => update
                            .attr("x",d=>d.x).attr("y",d=>d.y)
                            .attr("width",d=>d.w).attr("height",d=>d.h),
              exit => exit.remove()
            )
            .attr("fill", d => {
              if (d.type === "TP") return "#3498db";  // All blue
              if (d.type === "FP") return "#e74c3c";  // All red
              if (d.type === "FN") return "white";
              return "#ccc";
            })
            .attr("stroke", d => {
              if (bookmarked.has(d.d.instance_id)) return "#ff6b6b";
              if (d.type === "TP") return "none";
              if (d.type === "FP") return "black";
              if (d.type === "FN") return colorByClass(d.d.pred_label);
              return "none";
            })
            .attr("stroke-width", d => bookmarked.has(d.d.instance_id) ? 3 : (d.type === "FP" || d.type === "FN") ? 1.5 : 0)
            .style("fill-opacity", d => d.type === "FP" ? 0.6 : 1)
            .style("opacity", d => bookmarked.has(d.d.instance_id) ? 1 : 0.85);

          // Interactions: hover for details, click to bookmark, double-click for popup
          const tip = d3.select("#tooltip");
          rects.on("mouseover", (ev,dd)=>{
              const d = dd.d;
              tip.style("display","block").html(`${bookmarked.has(d.instance_id)?"‚≠ê ":""}Ground Truth: C${d.true_label}<br>Predicted Label: C${d.pred_label}<br>Prediction Score: ${d.pred_score.toFixed(3)}`);
              if (polylinesVisible && d.class_scores) showPolyline(d);
            })
            .on("mousemove", ev => tip.style("left",(ev.clientX+15)+"px").style("top",(ev.clientY-15)+"px"))
            .on("mouseout", ()=>{ tip.style("display","none"); if (polylinesVisible) hidePolyline(); })
            .on("click",(ev,dd)=>{
              const id=dd.d.instance_id;
              if (bookmarked.has(id)) {
                bookmarked.delete(id);
              } else {
                bookmarked.add(id);
              }
              updateBookmarkCount();
              draw(viewMode);
            })
            .on("dblclick",(ev,dd)=>{
              const d = dd.d;
              const scores = d.class_scores ? d.class_scores.map((v,i)=>`C${i}:${v.toFixed(3)}`).join(", ") : "Not available";
              const html = `
                <div style="position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#fff; border:2px solid #333; border-radius:8px; padding:16px; box-shadow:0 4px 16px rgba(0,0,0,0.3); z-index:10000; max-width:520px;">
                  <h3 style="margin:0 0 10px 0;">üîç Instance Details</h3>
                  <div style="font-size:13px;">
                    <p><b>GT:</b> C${d.true_label} &nbsp; <b>Pred:</b> C${d.pred_label} &nbsp; <b>Score:</b> ${d.pred_score.toFixed(3)}</p>
                    <p style="word-break:break-all;"><b>All Scores:</b> ${scores}</p>
                  </div>
                  <div style="text-align:center; margin-top:12px;">
                    <button onclick="this.parentElement.parentElement.remove()" style="padding:8px 16px; background:#3498db; color:#fff; border:none; border-radius:4px; cursor:pointer;">Close</button>
                  </div>
                </div>`;
              document.body.insertAdjacentHTML("beforeend", html);
            });

        } else {
          const layer = g.append("g").attr("class","layer stacks");
          const bars = [];
          for (let v=9; v>=0; v--){
            const binIdx = v, binY = yBin(binIdx) + (yBin.bandwidth()-16)/2;
            // In Stack mode, only show by predicted label to avoid duplication
            // Only show instances predicted as current class (TP + FP)
            const tp = bins[binIdx].TP.filter(d => shouldShow(d,"TP")).length;
            const fp = bins[binIdx].FP.filter(d => shouldShow(d,"FP")).length;
            const total = tp + fp, w = barWidth(total);
            let x = cfg.baselineX, tpW = total > 0 ? w * (tp/total) : 0, fpW = total > 0 ? w * (fp/total) : 0;
            if (tpW>0) { bars.push({key:`TP-${cls}-${binIdx}`, type:"TP", binIdx, x, y:binY, w:tpW, h:16, total, tp, fp, fn:0}); x+=tpW; }
            if (fpW>0) { bars.push({key:`FP-${cls}-${binIdx}`, type:"FP", binIdx, x, y:binY, w:fpW, h:16, total, tp, fp, fn:0}); }
          }
          const segs = layer.selectAll("rect.stack")
            .data(bars, d=>d.key)
            .join(
              enter => enter.append("rect").attr("class","stack")
                            .attr("x",d=>d.x).attr("y",d=>d.y)
                            .attr("width",d=>d.w).attr("height",d=>d.h)
                            .style("opacity",0.85),
              update => update.attr("x",d=>d.x).attr("y",d=>d.y).attr("width",d=>d.w).attr("height",d=>d.h),
              exit => exit.remove()
            )
            .attr("fill", d => {
              if (d.type === "FN") return "white";
              if (d.type === "TP") return "#3498db";  // All blue
              if (d.type === "FP") return "#e74c3c";  // All red
              return colorByClass(cls);
            })
            .attr("stroke", d => d.type==="FN" ? colorByClass(cls) : (d.type==="FP" ? "black" : "none"))
            .attr("stroke-width", d => d.type==="FN" ? 1.5 : (d.type==="FP" ? 1.5 : 0));

          const tip = d3.select("#tooltip");
          segs.on("mouseover",(ev,d)=>{
                const lo = (d.binIdx/10).toFixed(1), hi = ((d.binIdx+1)/10).toFixed(1);
                tip.style("display","block").html(`Bin ${d.binIdx} ¬∑ Score: [${lo}, ${hi})<br>Predicted as this class: ${d.total}<br>TP:${d.tp} FP:${d.fp}`);
              })
              .on("mousemove", ev => tip.style("left",(ev.clientX+12)+"px").style("top",(ev.clientY-10)+"px"))
              .on("mouseout", ()=> tip.style("display","none"));
        }
      });
    }

    // ---------- Polylines ----------
    function showPolyline(inst){
      poly.selectAll("*").remove();
      const pts = (inst.class_scores||[]).map((s,i)=>({
        x: i*cfg.subplotWidth + cfg.classOffset + cfg.yAxisOffset + cfg.baselineX,
        y: yScale(s), score:s, idx:i
      }));
      const line = d3.line().x(d=>d.x).y(d=>d.y);
      poly.append("path").datum(pts).attr("d",line).attr("stroke","#ff6b35").attr("stroke-width",2).attr("fill","none").attr("opacity",0.9).style("pointer-events","none");
      poly.selectAll("circle.dot").data(pts).join("circle").attr("class","dot").attr("cx",d=>d.x).attr("cy",d=>d.y).attr("r",3.5).attr("fill","#ff6b35").attr("stroke","#fff").attr("stroke-width",1).style("pointer-events","none");
    }
    function hidePolyline(){ poly.selectAll("*").remove(); }

    // ---------- Details ----------
    function showDetails(d){
      const scores = d.class_scores ? d.class_scores.map((v,i)=>`C${i}:${v.toFixed(3)}`).join(", ") : "Not available";
      const html = `
        <div style="position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#fff; border:2px solid #333; border-radius:8px; padding:16px; box-shadow:0 4px 16px rgba(0,0,0,0.3); z-index:10000; max-width:520px;">
          <h3 style="margin:0 0 10px 0;">üîç Instance Details</h3>
          <div style="font-size:13px;">
            <p><b>GT:</b> C${d.true_label} &nbsp; <b>Pred:</b> C${d.pred_label} &nbsp; <b>Score:</b> ${d.pred_score.toFixed(3)}</p>
            <p style="word-break:break-all;"><b>All Scores:</b> ${scores}</p>
          </div>
          <div style="text-align:center; margin-top:12px;">
            <button onclick="this.parentElement.parentElement.remove()" class="btn btn-blue">Close</button>
          </div>
        </div>`;
      document.body.insertAdjacentHTML("beforeend", html);
    }

    // ---------- Confusion Report ----------
    function confusionReport(){
      const confusionData = {};
      const classStats = {};
      data.forEach(d=>{
        classStats[d.true_label] ??= {TP:0, FP:0, FN:0, total:0};
        classStats[d.pred_label] ??= {TP:0, FP:0, FN:0, total:0};
        classStats[d.true_label].total++;
        if (d.true_label === d.pred_label) classStats[d.true_label].TP++;
        else {
          classStats[d.true_label].FN++;
          classStats[d.pred_label].FP++;
          const key = `${d.true_label}->${d.pred_label}`;
          confusionData[key] ??= {count:0, scores:[]};
          confusionData[key].count++; confusionData[key].scores.push(d.pred_score);
        }
      });
      const html = `
        <div style="position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#fff; border:2px solid #333; border-radius:8px; padding:16px; box-shadow:0 4px 16px rgba(0,0,0,0.3); z-index:10000; max-width:680px; max-height:70vh; overflow:auto;">
          <h3 style="margin:0 0 10px 0;">üìä Confusion Analysis Report</h3>
          <div style="background:#f8f9fa; padding:10px; border-radius:4px; margin-bottom:10px;">
            <div style="display:grid; grid-template-columns:auto auto auto auto auto; gap:10px; font-size:12px; font-weight:bold; border-bottom:1px solid #ddd; padding-bottom:5px;">
              <div>Class</div><div>Precision</div><div>Recall</div><div>F1</div><div>Support</div>
            </div>
            ${Object.keys(classStats).sort((a,b)=>a-b).map(k=>{
              const s=classStats[k]; const P=s.TP/(s.TP+s.FP)||0, R=s.TP/(s.TP+s.FN)||0, F1=2*P*R/(P+R)||0;
              return `<div style="display:grid; grid-template-columns:auto auto auto auto auto; gap:10px; font-size:12px; padding:3px 0;">
                        <div>C${k}</div><div>${P.toFixed(3)}</div><div>${R.toFixed(3)}</div><div>${F1.toFixed(3)}</div><div>${s.total}</div>
                      </div>`;
            }).join("")}
          </div>
          <div style="background:#fff3cd; padding:10px; border-radius:4px;">
            <h4 style="margin:0 0 6px 0; color:#856404;">‚ö†Ô∏è Top Confusions</h4>
            ${Object.entries(confusionData).sort(([,a],[,b])=>b.count-a.count).slice(0,5).map(([k,v])=>{
              const avg = d3.mean(v.scores)||0;
              return `<div style="margin:6px 0; padding:8px; background:rgba(255,193,7,0.1); border-left:3px solid #ffc107; font-size:12px;">
                        <strong>${k}</strong>: ${v.count} (avg score: ${avg.toFixed(3)})
                      </div>`;
            }).join("")}
          </div>
          <div style="text-align:center; margin-top:12px;">
            <button onclick="this.parentElement.parentElement.remove()" class="btn btn-blue">Close</button>
          </div>
        </div>`;
      document.body.insertAdjacentHTML("beforeend", html);
    }

    // ---------- Controls ----------
    function redraw(){ draw(document.getElementById("view_mode")?.value || "auto"); }
    document.getElementById("view_mode")?.addEventListener("change", redraw);
    document.getElementById("toggle-polylines")?.addEventListener("click", function(){
      polylinesVisible = !polylinesVisible;
      this.textContent = polylinesVisible ? "Hide" : "Show";
      this.classList.toggle("btn-green", !polylinesVisible);
      this.classList.toggle("btn-red", polylinesVisible);
      redraw();
    });
    document.getElementById("clear-bookmarks")?.addEventListener("click", function(){
      bookmarked.clear(); updateBookmarkCount(); redraw();
    });
    document.getElementById("instance-filter")?.addEventListener("change", function(){
      currentFilter = this.value; redraw();
    });
    document.getElementById("confusion-analysis")?.addEventListener("click", confusionReport);

    updateBookmarkCount();
    draw("auto");
  }

  // ---------- Bootstrap ----------
 (function boot(){
  const instEl  = document.getElementById('instances-json');
  const namesEl = document.getElementById('classnames-json');

  let instances = null;
  try {
    const txt = instEl ? instEl.textContent.trim() : "";
    instances = txt ? JSON.parse(txt) : null;
  } catch (e) {
    console.error("Failed to parse #instances-json:", e);
    instances = null;
  }

  let classNames = [];
  try {
    const txt = namesEl ? namesEl.textContent.trim() : "";
    classNames = txt ? JSON.parse(txt) : [];
  } catch (e) {
    console.warn("Failed to parse #classnames-json, fallback to empty []:", e);
    classNames = [];
  }

  if (!Array.isArray(instances) || instances.length === 0) {
    const mount = document.getElementById('multi-class-vis');
    if (mount) {
      mount.innerHTML = `
        <div style="text-align:center; padding:40px; color:#666; font-size:14px; background:#fff;">
          <h3 style="margin-top:0;">üö´ No Instance Data Detected</h3>
          <p>Please insert your data into <code>&lt;script id="instances-json" type="application/json"&gt;...&lt;/script&gt;</code>.</p>
          <p>Optional: Insert class names into <code>&lt;script id="classnames-json" ...&gt;</code>.</p>
        </div>`;
    }
    console.error("No instances provided. Aborting render.");
    return;
  }

  createClassifierSquaresVisualization(instances, classNames);
})();
  </script>
</body>
</html>

